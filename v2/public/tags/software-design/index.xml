<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Software Design on jeffhui.net</title>
    <link>http://localhost:1313/tags/software-design/</link>
    <description>Recent content in Software Design on jeffhui.net</description>
    <generator>Hugo -- 0.134.3</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 31 May 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/software-design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Two Kinds of Abstractions</title>
      <link>http://localhost:1313/2016/20-two-kinds-of-abstractions.html</link>
      <pubDate>Tue, 31 May 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/20-two-kinds-of-abstractions.html</guid>
      <description>&lt;p&gt;When someone talks about abstractions, they&amp;rsquo;re usually trying to make the
software more flexible. But that&amp;rsquo;s usually one of two kinds of abstractions.&lt;/p&gt;
&lt;h2 id=&#34;build-an-abstraction-to-_hide-an-implementation_&#34;&gt;Build an abstraction to &lt;em&gt;hide an implementation&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Abstractions that hide implementations are more commonly touted as good designs.
&lt;a href=&#34;https://github.com/lostisland/faraday&#34;&gt;Ruby&amp;rsquo;s Faraday&lt;/a&gt; abstracts the specific HTTP library implementation.
Rails&amp;rsquo; &lt;a href=&#34;http://guides.rubyonrails.org/active_record_basics.html&#34;&gt;ActiveRecord&lt;/a&gt; abstracts the SQL you need to write to
interface with a relational database. The
&lt;a href=&#34;https://en.wikipedia.org/wiki/Data_mapper_pattern&#34;&gt;Data Mapper Pattern&lt;/a&gt; abstracts the persistent storage from
your application.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Design of Software Solutions</title>
      <link>http://localhost:1313/2016/19-design-of-software-solutions.html</link>
      <pubDate>Sat, 30 Apr 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/19-design-of-software-solutions.html</guid>
      <description>&lt;p&gt;What&amp;rsquo;s the best way to model a solution? In software, there&amp;rsquo;s several common
ways of building solutions that solve specific problems. It&amp;rsquo;s worth trying to
identify their characteristics and the tradeoffs they make.&lt;/p&gt;
&lt;h2 id=&#34;architect-the-software-after-the-current-problem&#34;&gt;Architect the Software After the Current Problem&lt;/h2&gt;
&lt;p&gt;The easiest is way to model software. There&amp;rsquo;s no need to take in consideration
of future solutions the user made want.&lt;/p&gt;
&lt;p&gt;Sometimes this is what you need. If you&amp;rsquo;re writing a throw-away program, the
fastest possible way to implement it is to codify for the exact problem you&amp;rsquo;re
trying to solve. An example are most shell scripts. They tend to not be
abstracted and usually automate a very specific task.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Modeling the Domain</title>
      <link>http://localhost:1313/2016/16-domain-modeling/</link>
      <pubDate>Sun, 31 Jan 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/16-domain-modeling/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s mentally build an API for an an e-commerce site. Let&amp;rsquo;s say we&amp;rsquo;re tasked
with building the cart &amp;amp; checkout portion of the API. Building a RESTful API
seems like the natural choice. At first, a Cart seems like any other model
entity in the system. But what about an multi-page checkout step?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Allow partial updating of the Cart model (sounds like a job for PATCH). We
need to preserve as much information as possible on the server to allow the
user to pick up where they left off.&lt;/li&gt;
&lt;li&gt;Each update needs to be validated against the current known state of the
world. Store credit may not fully cover an order that has an upgraded shipping
method specified later on.&lt;/li&gt;
&lt;li&gt;The final cart has to be &amp;ldquo;commited&amp;rdquo; where final validations need to be
performed before commited.&lt;/li&gt;
&lt;li&gt;An finally, the committed cart requires taking to third party APIs all along
the way (shipping, credit card processing, tax calculations) as well as at the
commit point.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REST doesn&amp;rsquo;t provide an easy way to model this.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
