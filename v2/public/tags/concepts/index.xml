<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Concepts on jeffhui.net</title>
    <link>http://localhost:1313/tags/concepts/</link>
    <description>Recent content in Concepts on jeffhui.net</description>
    <generator>Hugo -- 0.134.3</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Jul 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/concepts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>What&#39;s Your Engineering Culture?</title>
      <link>http://localhost:1313/2016/22-whats-your-engineering-culture.html</link>
      <pubDate>Sun, 31 Jul 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/22-whats-your-engineering-culture.html</guid>
      <description>&lt;p&gt;When evaluating companies, its utmostly important to learn about the engineering
culture. Culture for a company is simular to scope for code – culture provides a
context for getting work done.&lt;/p&gt;
&lt;p&gt;Companies advertise their culture, but note that each company has a different
culture. There&amp;rsquo;s plenty of articles about culture, so I won&amp;rsquo;t bother covering
that. Just remember they aren&amp;rsquo;t necessarily the same. Companies tend not to be
explicit about making sure their process matches what you expect. Be suspicious
for a company that can&amp;rsquo;t explain it&amp;rsquo;s culture because that just means they&amp;rsquo;re
not activitely trying to cultivate one. And that means it&amp;rsquo;s implicitly defined
by the leaders of the company. Even if they choose not to define it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>TLDR Programming Concepts</title>
      <link>http://localhost:1313/2016/21-tldr-programming-concepts.html</link>
      <pubDate>Thu, 30 Jun 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/21-tldr-programming-concepts.html</guid>
      <description>&lt;p&gt;Trying to concisely describe concepts is an interesting exercise. The ideal goal
is to build upon existing concepts, but as you add more concepts you run the
risk of being inconsistent.&lt;/p&gt;
&lt;p&gt;So with at most two sentences, I present a list of common programming concepts.
This goes without warning that lossy compression is inevitable.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Data&lt;/strong&gt;: Ones and zeros.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Values&lt;/strong&gt;: Meaningful data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Types / Encodings&lt;/strong&gt;: Interpretations of values.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;State&lt;/strong&gt;: A value that changes over time. Usually also considered a Value.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Variables&lt;/strong&gt;: Names for values over time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Collections&lt;/strong&gt;: A value that&amp;rsquo;s a a group of values of same type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Structs&lt;/strong&gt;: A value that&amp;rsquo;s a group of values with possibly differing types.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Classes&lt;/strong&gt;: Structs with functions that have itself as the first argument.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inheritance&lt;/strong&gt;: A concise way to implement a class by referring to part of
its implementation from one class.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Multiple Inheritance&lt;/strong&gt;: A class that inherits from multiple other classes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Extensions&lt;/strong&gt;: Adding methods to a previously defined type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mixins&lt;/strong&gt;: Adding (Multiple) Inheritance to a previously defined type.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interface / Protocols&lt;/strong&gt;: Inheritance of a class that has only functions that
should be implemented by the class that inherits it.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Traits&lt;/strong&gt;: Interfaces that may have function implementations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generics&lt;/strong&gt;: Treating a type as a variable. Allows algorithms independent of
specific types.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type Classes&lt;/strong&gt;: Generic Interfaces.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Monad&lt;/strong&gt;: An interface defining the expected behavior for &lt;code&gt;map&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Functor&lt;/strong&gt;: An interface defining the expected behavior for &lt;code&gt;apply&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pointers&lt;/strong&gt;: A value that indicates where to find another value. An home
address is a pointer to a home.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Big-O Notation&lt;/strong&gt;: A method to estimate the number of main-memory operations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Slice&lt;/strong&gt;: A value that is a pointer and length into an existing collection&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Value Objects&lt;/strong&gt;: An struct / class with equality and hashCode semantics.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object-Oriented Programming&lt;/strong&gt;: The concept of classes talking to each other
using value objects.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Procedure&lt;/strong&gt;: A sequence of operations to execute. Most programming languages
mean procedure when they say function.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Function&lt;/strong&gt;: Vaguely defined / blurred by current norms. See Procedure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pure Function&lt;/strong&gt;: A procedure that returns the same output for the same
inputs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Side Effects&lt;/strong&gt;: Any observable state that occurs besides a return value.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Functional Programming&lt;/strong&gt;: The practice of using less state and more pure
functions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Code&lt;/strong&gt;: A value that is a series of operations&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AST (Abstract Syntax Tree)&lt;/strong&gt;: Hierarchy of typed code&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Program&lt;/strong&gt;: A collection of code that a computer that can execute.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compiler&lt;/strong&gt;: Program that take code and produce programs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interpreter&lt;/strong&gt;: A program that executes code without producing a program.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Emulator&lt;/strong&gt;: A program that mimics the behavior of hardware.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Virtual Machine&lt;/strong&gt;: A computer emulator where the hardware may not actually
exist (eg - Java Virtual Machine).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Static&lt;/strong&gt;: Known at compile-time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic&lt;/strong&gt;: Known at execution-time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type Checker&lt;/strong&gt;: A program that validates what types flowing through your
code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type Inference&lt;/strong&gt;: A compiler or interpreter feature can that deduce types
without always explicitly specifying it in code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimization&lt;/strong&gt;: Writing code for the computer first, instead of humans.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Performance&lt;/strong&gt;: Turning memory operations for lower frequency, and higher
throughput.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reference Counting&lt;/strong&gt;: Counting number of owners of a piece of memory to know
when to free it.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Garbage Collection&lt;/strong&gt;: An embedded program that frees another program&amp;rsquo;s
memory that is no longer being used.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reflection&lt;/strong&gt;: Code that can inspect and/or modify itself as it&amp;rsquo;s executing.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Macros&lt;/strong&gt;: An operation that can be translated to a sequence of operations
before program execution.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JIT (Just-In-Time) Compilation&lt;/strong&gt;: A feature of interpreters or emulators
that compiles code during its execution.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;The last concept pushes the limits of definitions this concise. Some interesting
implications result from these definitions:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Two Kinds of Abstractions</title>
      <link>http://localhost:1313/2016/20-two-kinds-of-abstractions.html</link>
      <pubDate>Tue, 31 May 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/20-two-kinds-of-abstractions.html</guid>
      <description>&lt;p&gt;When someone talks about abstractions, they&amp;rsquo;re usually trying to make the
software more flexible. But that&amp;rsquo;s usually one of two kinds of abstractions.&lt;/p&gt;
&lt;h2 id=&#34;build-an-abstraction-to-_hide-an-implementation_&#34;&gt;Build an abstraction to &lt;em&gt;hide an implementation&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;Abstractions that hide implementations are more commonly touted as good designs.
&lt;a href=&#34;https://github.com/lostisland/faraday&#34;&gt;Ruby&amp;rsquo;s Faraday&lt;/a&gt; abstracts the specific HTTP library implementation.
Rails&amp;rsquo; &lt;a href=&#34;http://guides.rubyonrails.org/active_record_basics.html&#34;&gt;ActiveRecord&lt;/a&gt; abstracts the SQL you need to write to
interface with a relational database. The
&lt;a href=&#34;https://en.wikipedia.org/wiki/Data_mapper_pattern&#34;&gt;Data Mapper Pattern&lt;/a&gt; abstracts the persistent storage from
your application.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Design of Software Solutions</title>
      <link>http://localhost:1313/2016/19-design-of-software-solutions.html</link>
      <pubDate>Sat, 30 Apr 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/19-design-of-software-solutions.html</guid>
      <description>&lt;p&gt;What&amp;rsquo;s the best way to model a solution? In software, there&amp;rsquo;s several common
ways of building solutions that solve specific problems. It&amp;rsquo;s worth trying to
identify their characteristics and the tradeoffs they make.&lt;/p&gt;
&lt;h2 id=&#34;architect-the-software-after-the-current-problem&#34;&gt;Architect the Software After the Current Problem&lt;/h2&gt;
&lt;p&gt;The easiest is way to model software. There&amp;rsquo;s no need to take in consideration
of future solutions the user made want.&lt;/p&gt;
&lt;p&gt;Sometimes this is what you need. If you&amp;rsquo;re writing a throw-away program, the
fastest possible way to implement it is to codify for the exact problem you&amp;rsquo;re
trying to solve. An example are most shell scripts. They tend to not be
abstracted and usually automate a very specific task.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Observation</title>
      <link>http://localhost:1313/2016/17-observation.html</link>
      <pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/17-observation.html</guid>
      <description>&lt;p&gt;The more you learn, the more this skill seems to be necessary. When missing a
bug or a refactor opportunity, I wonder how did I miss this? Sure, everyone
wants to learn from their mistakes. But noticing the little details gives you
the opportunity to adapt. Massive function definitions starts off looking like
an common pattern for code that needs to be refactored. Those dozen one-letter
variables names probably should be better named. Shadowing a variable is prone
to introduce errors in the future. All those mental notes form from being able
to observe it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Modeling the Domain</title>
      <link>http://localhost:1313/2016/16-domain-modeling/</link>
      <pubDate>Sun, 31 Jan 2016 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2016/16-domain-modeling/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s mentally build an API for an an e-commerce site. Let&amp;rsquo;s say we&amp;rsquo;re tasked
with building the cart &amp;amp; checkout portion of the API. Building a RESTful API
seems like the natural choice. At first, a Cart seems like any other model
entity in the system. But what about an multi-page checkout step?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Allow partial updating of the Cart model (sounds like a job for PATCH). We
need to preserve as much information as possible on the server to allow the
user to pick up where they left off.&lt;/li&gt;
&lt;li&gt;Each update needs to be validated against the current known state of the
world. Store credit may not fully cover an order that has an upgraded shipping
method specified later on.&lt;/li&gt;
&lt;li&gt;The final cart has to be &amp;ldquo;commited&amp;rdquo; where final validations need to be
performed before commited.&lt;/li&gt;
&lt;li&gt;An finally, the committed cart requires taking to third party APIs all along
the way (shipping, credit card processing, tax calculations) as well as at the
commit point.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REST doesn&amp;rsquo;t provide an easy way to model this.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Daily Processes Check-In</title>
      <link>http://localhost:1313/2015/15-daily-processes.html</link>
      <pubDate>Mon, 30 Nov 2015 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2015/15-daily-processes.html</guid>
      <description>&lt;p&gt;&lt;em&gt;Instead of sounding prescriptive, this article is much more descriptive.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m describing my regular workflows: what is working; what isn&amp;rsquo;t working. I&amp;rsquo;m
documenting this for completely selfish reasons since it&amp;rsquo;s useful to track
progression (if any). It happens to be a great inflection point since a recent
illness has thrown me off my routine in the past week.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Like most people, there&amp;rsquo;s a need to regularly do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Respond to messages (twitter, facebook, texts)&lt;/li&gt;
&lt;li&gt;Respond to mail (physical, email)&lt;/li&gt;
&lt;li&gt;Attend events (birthdays, social gatherings, meetups)&lt;/li&gt;
&lt;li&gt;Capture ideas (they tend to come up in the most random places)&lt;/li&gt;
&lt;li&gt;Living (rent, bills, taxes, laundry, cleaning)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All while (attempting) to achieve other goals:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Going Fast by Going Slow</title>
      <link>http://localhost:1313/2015/14-going-fast-by-going-slow.html</link>
      <pubDate>Sat, 31 Oct 2015 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2015/14-going-fast-by-going-slow.html</guid>
      <description>&lt;p&gt;People always ask about how did you learn this or work so quickly doing that?
It&amp;rsquo;s a tough question to answer elegantly. And it&amp;rsquo;s a cop-out to vaguely say I
spent my free time looking into that particular topic. It&amp;rsquo;s a
socially-acceptable excuse.&lt;/p&gt;
&lt;p&gt;But no doubt that this requires time. The time spent learning comes from
somewhere, since we all only have 24 hours in a day for this. In our field,
there&amp;rsquo;s always time you must dedicate to learning to keep up to date.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Process is King</title>
      <link>http://localhost:1313/2015/13-Process-is-King.html</link>
      <pubDate>Wed, 30 Sep 2015 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2015/13-Process-is-King.html</guid>
      <description>&lt;p&gt;There&amp;rsquo;s a process behind every result.&lt;/p&gt;
&lt;p&gt;If you say, &amp;ldquo;we have no process, there&amp;rsquo;s no meetings&amp;rdquo;, then that&amp;rsquo;s your process.
Admitting to no process simply indicates that you don&amp;rsquo;t have it formalized. A
poorly defined process hurts. Processes enable efficiency and consistency. They
can also act like a communication protocol among team members, teams, and
organizations. Process can improve your quality.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s think about how you deploy an application. What does that process look
like? A poorly defined deployment process is inconsistent – something
undesirable for a deployment. At minimum, a quick checklist works:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Communicating as an Engineer</title>
      <link>http://localhost:1313/2015/12-communicating-as-an-engineer.html</link>
      <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2015/12-communicating-as-an-engineer.html</guid>
      <description>&lt;p&gt;As an engineer, one of the most valuable skills you can have is to communicate
effectively. This applies both to your follow engineers as well as non-engineers
(PMs, designers, business). Obviously, this advice is generally applicable, but
many engineers don&amp;rsquo;t craft their communication to the business well. Common
problems are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Talking &lt;em&gt;too much&lt;/em&gt; about technical implementation.&lt;/li&gt;
&lt;li&gt;Talking &lt;em&gt;too little&lt;/em&gt; about technical implementation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Too much technical implementation drowns out the important details that
businesses are concerned about. It drags on discussions and meetings
unnecessarily. Imagine if a designer talked for hours about how they picked the
correct border radius value and color for their buttons in a meeting. That&amp;rsquo;s a
waste of time for business stakeholders and engineers in that meeting. Getting
far into the weeds like that quickly wastes discussions or
meetings&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mental Schemas</title>
      <link>http://localhost:1313/2015/11-mental-schemas.html</link>
      <pubDate>Thu, 30 Jul 2015 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2015/11-mental-schemas.html</guid>
      <description>&lt;p&gt;It is difficult to always be improving in the software industry. In creative
fields, many artists &lt;a href=&#34;https://youtu.be/ikAb-NYkseI?t=9m41s&#34;&gt;talk&lt;/a&gt; about
&lt;a href=&#34;http://www.goodreads.com/quotes/309485-nobody-tells-this-to-people-who-are-beginners-i-wish&#34;&gt;churn&lt;/a&gt;.
When starting out, there&amp;rsquo;s an enormous amount of work to produce to get better.
If you&amp;rsquo;re new, there&amp;rsquo;s a massive amount of bad code you need to write. That&amp;rsquo;s
OK, it&amp;rsquo;s necessary. But the rate of improvement decays as time progresses. As
your notoriety grows, you can no longer just crank out code to get better, how
can you preserve some rate of improvement? It feels like the rate of learning
looks like this:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Software as Bridges</title>
      <link>http://localhost:1313/2015/10-software-bridges.html</link>
      <pubDate>Mon, 29 Jun 2015 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2015/10-software-bridges.html</guid>
      <description>&lt;hr&gt;
&lt;p&gt;Software is always challenging to explain to non-engineers and having a metaphor
is valuable to explain complex concepts. Bridges happen to be a good analogy to
software. But the devil is always in the details.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;10-software-bridges/MillauBridge.jpg&#34; alt=&#34;Millau Viaduct&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;Any piece of software provides a benefit to its users. It&amp;rsquo;s similar to people
using bridges to cross rivers. As with bridges, many kinds of software can solve
the same problems.&lt;/p&gt;
&lt;p&gt;Some bridges support many cars and pedestrians which is analogous to a
high-throughput like a server that can support many users. Others are very nice
walkways with trees, a highly usable piece of software that supports only a few
users. Most of the time, users only see the bridge from the top. Like seeing
only the tip of an iceberg.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
