<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>QuickCheck on jeffhui.net</title>
    <link>http://localhost:1313/tags/quickcheck/</link>
    <description>Recent content in QuickCheck on jeffhui.net</description>
    <generator>Hugo -- 0.134.3</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Jan 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/quickcheck/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>check.statem: Generating Test Programs</title>
      <link>http://localhost:1313/2020/01-check.statem.html</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2020/01-check.statem.html</guid>
      <description>&lt;p&gt;One of the most interesting parts of generative testing (aka
&lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt;). Is state machine testing. The original purpose I
built &lt;a href=&#34;http://github.com/jeffh/Fox&#34;&gt;Fox&lt;/a&gt; was to explore state machine testing. In particular, the talk
from John Hughes video was inspirational to exploring this further:&lt;/p&gt;



&lt;p&gt;
&lt;iframe class=&#34;center lit&#34; width=&#34;560&#34; height=&#34;315&#34;
src=&#34;https://www.youtube-nocookie.com/embed/zi0rHwfiX1Q&#34; frameborder=&#34;0&#34;
allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34;
allowfullscreen&gt;&lt;/iframe&gt;
&lt;/p&gt;

&lt;p&gt;In short, John makes a case: dynamically generating state machines to detect
errors that is more effective and economical than traditional example based
tests. There&amp;rsquo;s lots of work managing example based tests that can be better
solved with generative testing.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Generative Testing</title>
      <link>http://localhost:1313/2015/07-Generative-Testing.html</link>
      <pubDate>Sat, 31 Jan 2015 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/2015/07-Generative-Testing.html</guid>
      <description>&lt;p&gt;It&amp;rsquo;s no secret that I&amp;rsquo;ve been interested in testing. Most of the &lt;a href=&#34;https://github.com/pivotal/cedar&#34; title=&#34;Cedar - BDD for Objective-C&#34;&gt;work&lt;/a&gt;
&lt;a href=&#34;https://github.com/Quick/Quick&#34; title=&#34;Quick - BDD for Swift and Objective-C&#34;&gt;I&amp;rsquo;ve&lt;/a&gt; &lt;a href=&#34;https://github.com/Nimble/Nimble&#34; title=&#34;Nimble Matcher Library for Swift and Objective-C&#34;&gt;done&lt;/a&gt; are around example-based testing. While useful,
it&amp;rsquo;s interesting to look at other communities for inspiration. I&amp;rsquo;m specifically
fascinated in the functional programming community. Generative testing in
particular. It was popularized in the early 2000s by a famous implementation in
Haskell, &lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;QuickCheck&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In short, generative testing is allows you specify properties your software
should have. Then the testing library &lt;em&gt;generates&lt;/em&gt; test cases. It&amp;rsquo;s an
alternative path the functional community has taken when it comes to testing.
This becomes evident since testing functional code becomes mostly boilerplate
management:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
